<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - nearest neighbour</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link rel="stylesheet" type="text/css" href="style.css" />
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#info {
				text-align: center;
				padding: 5px;
				position: absolute;
				width: 100%;
				color: white;
			}
		</style>
	</head>
	<body>

	    <div id="drop-area">
			<form class="my-form">
			  <p>Upload multiple files with the file dialog or by dragging and dropping images onto the dashed region</p>
			  <input type="file" id="fileElem" multiple accept="image/*" onchange="handleFiles(this.files)">
			  <label class="button" for="fileElem">Select some files</label>
			</form>
		</div>
		  <button onclick="doThreeJS()">dasdas</button>
	
		<div id="info" style="display:none;"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - typed arrays - nearest neighbour for 500,000 sprites</div>

		<script type="text/javascript">


            let file_Metadata = {}
            file_Metadata.properties = [];
            let properties = [];


            let dropArea = document.getElementById('drop-area')
            ;['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false)
            })

            function preventDefaults (e) {
            e.preventDefault()
            e.stopPropagation()
            }


            ;['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false)
            })

            ;['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false)
            })

            function highlight(e) {
            dropArea.classList.add('highlight')
            }

            function unhighlight(e) {
            dropArea.classList.remove('highlight')
            }


        dropArea.addEventListener('drop', handleDrop, false)

        function handleDrop(e) {
        let dt = e.dataTransfer
        let files = dt.files

        handleFiles(files)
        }

        let what = [];

        

        function handleFiles(files) {
        
        let fileArray = [...files]
        var actions = fileArray.map(uploadFile);
        
        }

        


        function parseValues(property) {
            
            let result = {}
            
            let name = property[0];
            
            result[name+"_X"] = property[1]
            result[name+"_Y"] = property[2]
            result[name+"_Z"] = property[3]
            file_Metadata[name] = result;
        }


        function uploadFile(file, value) {
    

        var read = new FileReader();
        
        if(file.name.split(".").length === 1) {
            read.readAsArrayBuffer(file);
        } else {
            read.readAsBinaryString(file);
        }

        read.onloadend = function(){                               
           
            // If file is not metadata file
            
                if(file.name.split(".").length === 1) {
                
                let exists = false;
                
                file_Metadata.properties.map(property => {
                    console.log(String(property.filename));
                    console.log(String(file.name))
                    let why = property.filename === file.name
                    if(why) {
                        console.log("yeah")
                        console.log(read.result)

                        
                        
                        var view   = new Float32Array(read.result);
                        var whatever = new DataView(read.result).getFloat32(0, false) 
                        console.log(whatever)
                        console.log(view)
                        property.values = view
                        exists = true;
                    }
                    console.log(property)
                    
                    console.log(exists)
                })
                
                if(!exists) {
                    properties.push({"filename": file.name, "value" : read.result})
                }     

                
                console.log(file_Metadata)
                
                
            } else {
            // Metadata file
            console.log("nay")
            let metadata = read.result.split("\n");
            metadata.map(data => {
                let property = data.split(" ")[0]

                    if((property === 'AXIS_O') || (property === 'AXIS_U') || (property === 'AXIS_V') || (property === 'AXIS_W') || (property === 'AXIS_MIN') || (property === 'AXIS_MAX') || (property === 'AXIS_N')) {
                        let values = data.split(" ")
                        parseValues(values)
                    }

                    if(property === 'PROPERTY') {
                        let values = data.split(" ")
                        let name = values[2];
                        let id = values[1]
                        
                        file_Metadata.properties.push({ "id": id, "name" : name});
                    }

                    if(property === 'PROP_FILE') {
                        let values = data.split(" ")
                        file_Metadata.properties.map(property => {
                            if(property.id === values[1]) {
                                property.filename = values[2];
                            }
                        })
                    }
                    
                    
            })
            console.log(properties);
            if(properties.length > 0) {
                console.log("wtf")
                properties.map(property => {
                    fileMetadata.properties.map(metaproperty => {
                        if((!metaproperty.values) && (metaproperty.filename === property.filename)) {
                            metaproperty.values = property.value
                        }
                    })
                })
            }}} 
        }
		

        </script>
		
		<script src="three.js"></script>
		<script src="js/TypedArrayUtils.js"></script>
		<script src="js/controls/FirstPersonControls.js"></script>
		<script type="x-shader/x-vertex" id="vertexshader">

		
		
		
			//uniform float zoom;

			attribute float alpha;

			varying float vAlpha;
			varying vec4 vExtraData;

			void main() {

				vAlpha = 1.0 - alpha;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = 10.0 * ( 300.0 / -mvPosition.z );
				
				vExtraData.a = 1.0;
				
				gl_Position = projectionMatrix * mvPosition;
				
				
				//if(-800.0 < mvPosition.z)
				//{
				//	vExtraData.a = 0.0;
				//	gl_PointSize = 0.0;
				//	gl_Position = vec4(-1000,-1000,-1000,-1000);
				//}

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform sampler2D tex1;

			varying float vAlpha;
			varying vec4 vExtraData;

			void main() {
				if(vExtraData.a < 0.1)
					discard;
					
				vec4 color = texture2D( tex1, gl_PointCoord );
				
				if(color.a < 0.5)
					discard;
				//if((vExtraData.r / vExtraData.g) < 1.0
				//&& (vExtraData.b / vExtraData.g) < 1.0)
				//	discard;
					
				gl_FragColor = vec4(0,0,0,1);
				gl_FragColor.r = vAlpha;
				gl_FragColor.a = color.a;
				gl_FragColor.r = ( 1.0 - gl_FragColor.r ) * vAlpha + gl_FragColor.r;

			}

		</script>
		<script>

			var camera, scene, renderer;
			var controls;


			
			var maxDistance = Math.pow( 120, 2 );
			var positions, alphas, particles, _particleGeom;

			var clock = new THREE.Clock();

			var blocker = document.getElementById( 'blocker' );
			var instructions = document.getElementById( 'instructions' );


			function init(i_prop_data) {
			
				var prop_max_x = i_prop_data.AXIS_N.AXIS_N_X;
				var prop_max_y = i_prop_data.AXIS_N.AXIS_N_Y;
				var prop_max_z = i_prop_data.AXIS_N.AXIS_N_Z;
				
				
				var max_size_x = prop_max_x;
				var max_size_y = prop_max_y;
				var max_size_z = prop_max_z;
				
				var amountOfParticles = 6000000;// max_size_x * max_size_y * max_size_z;
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000000 );

				scene = new THREE.Scene();

				controls = new THREE.FirstPersonControls( camera );
				controls.movementSpeed = 200;
				controls.lookSpeed = 0.1;

				// add a skybox background
				var cubeTextureLoader = new THREE.CubeTextureLoader();

				cubeTextureLoader.setPath( 'textures/cube/skybox/' );

				var cubeTexture = cubeTextureLoader.load( [
					'px.jpg', 'nx.jpg',
					'py.jpg', 'ny.jpg',
					'pz.jpg', 'nz.jpg',
				] );

				scene.background = cubeTexture;

				//

				
				renderer = new THREE.WebGLRenderer(); // Detector.webgl? new THREE.WebGLRenderer(): new THREE.CanvasRenderer()
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				
				renderer.sortObjects = true;
				document.body.appendChild( renderer.domElement );

				// create the custom shader

				var textureLoader = new THREE.TextureLoader();

				var imagePreviewTexture = textureLoader.load( 'textures/point.png' );

				imagePreviewTexture.minFilter = THREE.LinearMipMapLinearFilter;
				imagePreviewTexture.magFilter = THREE.LinearFilter;

				var pointShaderMaterial = new THREE.ShaderMaterial( {
					uniforms: {
						tex1: { value: imagePreviewTexture },
						zoom: { value: 9.0 }
					},
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					transparent: true
				} );


				//create particles with buffer geometry
				var distanceFunction = function ( a, b ) {

					return Math.pow( a[ 0 ] - b [0 ], 2 ) +  Math.pow( a[ 1 ] - b[ 1 ], 2 ) +  Math.pow( a[ 2 ] - b[ 2 ], 2 );

				};

				var data = JSON.parse(localStorage.getItem('data'));
				console.log(data);
				
				positions = new Float32Array( amountOfParticles * 3 );
				alphas = new Float32Array( amountOfParticles );

				_particleGeom = new THREE.BufferGeometry();
				_particleGeom.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				_particleGeom.addAttribute( 'alpha', new THREE.BufferAttribute( alphas, 1 ) );

				particles = new THREE.Points( _particleGeom, pointShaderMaterial );
				particles.material.depthWrite = true;
				particles.material.transparent = false;
				particles.material.blending = THREE.NormalBlending;
				//particles.material.combine = THREE.MixOperation;
				
				var x_offset = 0;
				var y_offset = 0;
				var z_offset = 0;
				
				var prop_LOD_modifier = 1;// only used as offset for now (only take every x'th point)
				var prop_value_modifier = 0.01;// only used as offset for now (only take every x'th point)
				
				console.log("creating own grid")
				
				var grid_point_count = 0;
				for ( var curr_z = 0; curr_z < max_size_z; curr_z++ ) {
					for ( var curr_y = 0; curr_y < max_size_y; curr_y++ ) {
						for ( var curr_x = 0; curr_x < max_size_x; curr_x++ ) {
							var prop_x = x_offset + curr_x * prop_LOD_modifier;
							var prop_y = y_offset + curr_y * prop_LOD_modifier;
							var prop_z = z_offset + curr_z * prop_LOD_modifier;
							var prop_index = (prop_x + prop_y * prop_max_x + prop_z * prop_max_x * prop_max_y);
							var prop_data =  i_prop_data.properties[0].values[ prop_index ];
							
							
							//var own_grid_index = (curr_x + curr_y * max_size_x + curr_z * max_size_x * max_size_y);
							
							
							if(prop_data == -99999)
							{

								
							}else{
								positions[ 3 * grid_point_count + 0 ] = 3 * curr_x;
								positions[ 3 * grid_point_count + 1 ] = 3 * curr_y;
								positions[ 3 * grid_point_count + 2 ] = 3 * curr_z;
								alphas[ grid_point_count ] = prop_data * prop_value_modifier;
								grid_point_count++;
							}
						}
					}
				}
				
				for ( var i_rest = grid_point_count; i_rest < amountOfParticles; i_rest++ ) {
					positions[ 3 * i_rest + 0 ] = -100000;
					positions[ 3 * i_rest + 1 ] = -100000;
					positions[ 3 * i_rest + 2 ] = -100000;
					alphas[ i_rest ] = 0;
				}
				
				console.log(grid_point_count);

				var measureStart = new Date().getTime();

				
				// creating the kdtree takes a lot of time to execute, in turn the nearest neighbour search will be much faster
				//kdtree = new THREE.TypedArrayUtils.Kdtree( positions, distanceFunction, 3 );

				//console.log( 'TIME building kdtree', new Date().getTime() - measureStart );

				// display particles after the kd-tree was generated and the sorting of the positions-array is done
				scene.add( particles );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				controls.handleResize();
			}

			function animate() {

				requestAnimationFrame( animate );

				//
				//displayNearest( camera.position );

				controls.update( clock.getDelta() );

				renderer.render( scene, camera );

			}

			function displayNearest( position ) {

				// take the nearest 200 around him. distance^2 'cause we use the manhattan distance and no square is applied in the distance function
				var imagePositionsInRange = kdtree.nearest( [ position.x, position.y, position.z ], 100, maxDistance );

				// We combine the nearest neighbour with a view frustum. Doesn't make sense if we change the sprites not in our view... well maybe it does. Whatever you want.
				var _frustum = new THREE.Frustum();
				var _projScreenMatrix = new THREE.Matrix4();

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				for ( var i = 0, il = imagePositionsInRange.length; i < il; i ++ ) {

					var object = imagePositionsInRange[ i ];
					var objectPoint = new THREE.Vector3().fromArray( object[ 0 ].obj );

					if ( _frustum.containsPoint( objectPoint ) ) {

						var objectIndex = object[ 0 ].pos;

						// set the alpha according to distance
						alphas[ objectIndex ] = 1.0 / maxDistance * object[ 1 ];

						// update the attribute
						_particleGeom.attributes.alpha.needsUpdate = true;

					}

				}

			}

			function doThreeJS() {
				document.getElementById("drop-area").style.display="none";
				document.getElementById("info").style.display="block";
				
				init(file_Metadata);
				animate();
			}

		</script>
	</body>
</html>
